let native;
/**
 * @ignore
 */
export function setNative(newNative) {
    native = newNative;
}
/**
 * This identifies the task a model performs.
 */
export var Task;
(function (Task) {
    Task["Regression"] = "regression";
    Task["BinaryClassification"] = "binary_classification";
    Task["MulticlassClassification"] = "multiclass_classification";
})(Task || (Task = {}));
/**
 * This identifies the type of a feature contribution.
 */
export var FeatureContributionType;
(function (FeatureContributionType) {
    FeatureContributionType["Identity"] = "identity";
    FeatureContributionType["Normalized"] = "normalized";
    FeatureContributionType["OneHotEncoded"] = "one_hot_encoded";
    FeatureContributionType["BagOfWords"] = "bag_of_words";
    FeatureContributionType["BagOfWordsCosineSimilarity"] = "bag_of_words_cosine_similarity";
    FeatureContributionType["WordEmbedding"] = "word_embedding";
})(FeatureContributionType || (FeatureContributionType = {}));
/**
 * Use this class to load a model, make predictions, and log events to the app.
 */
export class Model {
    model;
    tangramUrl;
    logQueue = [];
    constructor(input, options) {
        if (typeof input === "string") {
            this.model = native.loadModelFromPath(input);
        }
        else {
            this.model = native.loadModelFromArrayBuffer(input);
        }
        this.tangramUrl = options?.tangramUrl ?? "https://app.tangram.dev";
    }
    /**
     * Retrieve the model's id.
     * @returns The model's id.
     */
    id() {
        return native.modelId(this.model);
    }
    /**
     * Make a prediction!
     * @param input The input to the prediction, either a single `PredictInput` or an array of `PredictInput`s.
     * @param options An optional [[`PredictOptions`]] value to set options for the prediction.
     * @returns A single [[`PredictOutput`]] if `input` was a single [[`PredictInput`]], or an array of [[`PredictOutput`]]s if `input` was an array of [[`PredictInput`]]s.
     */
    predict(input, options) {
        return native.predict(this.model, input, options);
    }
    /**
     * Send a prediction event to the app. If you want to batch events, you can use [[`Model.enqueueLogTrueValue`]] instead.
     * @param args The arguments to use to produce the prediction event.
     */
    async logPrediction(args) {
        this.logEvent(this.predictionEvent(args));
    }
    /**
     * Send a true value event to the app. If you want to batch events, you can use [[`Model.enqueueLogTrueValue`]] instead.
     * @param args The arguments to use to produce the true value event.
     */
    async logTrueValue(args) {
        this.logEvent(this.trueValueEvent(args));
    }
    /**
     * Add a prediction event to the queue. Remember to call [[`Model.flushLogQueue`]] at a later point to send the event to the app.
     * @param args The arguments to use to produce the prediction event.
     */
    enqueueLogPrediction(args) {
        this.logQueue.push(this.predictionEvent(args));
    }
    /**
     *  Add a true value event to the queue. Remember to call [[`Model.flushLogQueue`]] at a later point to send the event to the app.
     * @param args The arguments to use to produce the true value event.
     */
    enqueueLogTrueValue(args) {
        this.logQueue.push(this.trueValueEvent(args));
    }
    /**
     * Send all events in the queue to the app.
     */
    async flushLogQueue() {
        await this.logEvents(this.logQueue);
        this.logQueue = [];
    }
    async logEvent(event) {
        await this.logEvents([event]);
    }
    async logEvents(events) {
        let url = this.tangramUrl + "/track";
        let body = JSON.stringify(events);
        if (typeof fetch === "undefined") {
            throw Error("Tangram cannot find the fetch function.");
        }
        let response = await fetch(url, {
            body,
            headers: {
                "Content-Type": "application/json",
            },
            method: "POST",
        });
        if (!response.ok) {
            throw Error(await response.text());
        }
    }
    predictionEvent(args) {
        return {
            modelId: this.id(),
            type: "prediction",
            date: new Date().toISOString(),
            identifier: args.identifier,
            input: args.input,
            output: {
                ...args.output,
                featureContributions: null,
            },
            options: args.options,
        };
    }
    trueValueEvent(args) {
        return {
            modelId: this.id(),
            type: "true_value",
            date: new Date().toISOString(),
            identifier: args.identifier,
            trueValue: args.trueValue,
        };
    }
}
//# sourceMappingURL=common.js.map